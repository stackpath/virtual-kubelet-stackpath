// Code generated by go-swagger; DO NOT EDIT.

package workload_models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// V1WorkloadInstanceSecurityContext Security configuration that will be applied to all containers in the workload instance
//
// swagger:model v1WorkloadInstanceSecurityContext
type V1WorkloadInstanceSecurityContext struct {

	// The user GID to run the entry point of the container process
	RunAsGroup string `json:"runAsGroup,omitempty"`

	// Indicates that the container must run as a non-root user
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty"`

	// The user UID to run the entry point of the container process
	RunAsUser string `json:"runAsUser,omitempty"`

	// The additional list of user groups applied to the first process run in each container running in the workload instance
	SupplementalGroups []string `json:"supplementalGroups"`

	// The list of kernel sysctl parameters to optimize the performance of a containersupported sysctls are [kernel.msgmax, kernel.msgmnb, kernel.pid_max, kernel.shmall, kernel.shmmax, kernel.shm_rmid_forced, net.core.netdev_budget, net.core.netdev_budget_usecs, net.core.netdev_max_backlog, net.core.optmem_max, net.core.rmem_default, net.core.rmem_max, net.core.somaxconn, net.core.wmem_default, net.core.wmem_max, net.ipv4.conf.$interface.accept_local, net.ipv4.conf.$interface.arp_announce, net.ipv4.conf.$interface.arp_ignore, net.ipv4.conf.$interface.rp_filter, net.ipv4.conf.all.accept_local, net.ipv4.conf.all.arp_announce, net.ipv4.conf.all.arp_ignore, net.ipv4.conf.all.force_igmp_version, net.ipv4.conf.all.rp_filter, net.ipv4.conf.default.accept_local, net.ipv4.conf.default.accept_source_route, net.ipv4.conf.default.rp_filter, net.ipv4.conf.lo.accept_local, net.ipv4.conf.lo.arp_announce, net.ipv4.conf.lo.arp_filter, net.ipv4.conf.lo.arp_ignore, net.ipv4.conf.lo.rp_filter, net.ipv4.ip_forward, net.ipv4.ip_local_port_range, net.ipv4.ip_local_reserved_ports, net.ipv4.ip_unprivileged_port_start, net.ipv4.ping_group_range, net.ipv4.tcp_base_mss, net.ipv4.tcp_congestion_control, net.ipv4.tcp_early_retrans, net.ipv4.tcp_ecn, net.ipv4.tcp_enable_last_ack_timer, net.ipv4.tcp_fin_timeout, net.ipv4.tcp_frto_response, net.ipv4.tcp_last_ack_timeout, net.ipv4.tcp_max_orphans, net.ipv4.tcp_max_syn_backlog, net.ipv4.tcp_mem, net.ipv4.tcp_mtu_probing, net.ipv4.tcp_no_metrics_save, net.ipv4.tcp_orphan_retries, net.ipv4.tcp_retries2, net.ipv4.tcp_rmem, net.ipv4.tcp_rto_max, net.ipv4.tcp_slow_start_after_idle, net.ipv4.tcp_syncookies, net.ipv4.tcp_timestamps, net.ipv4.tcp_tw_recycle, net.ipv4.tcp_tw_reuse, net.ipv4.tcp_wmem, net.ipv4.vs.debug_level, net.ipv6.conf.$interface.autoconf, net.ipv6.conf.all.accept_ra, net.ipv6.conf.all.autoconf, net.ipv6.conf.all.disable_ipv6, net.ipv6.conf.default.autoconf, net.ipv6.conf.lo.accept_dad, net.ipv6.conf.lo.autoconf, net.ipv6.conf.lo.dad_transmits, net.ipv6.route.max_size, vm.dirty_background_ratio, vm.dirty_ratio, vm.max_map_count, vm.min_free_kbytes, vm.panic_on_oom, vm.swappiness]
	Sysctls []*V1Sysctl `json:"sysctls"`
}

// Validate validates this v1 workload instance security context
func (m *V1WorkloadInstanceSecurityContext) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSysctls(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1WorkloadInstanceSecurityContext) validateSysctls(formats strfmt.Registry) error {
	if swag.IsZero(m.Sysctls) { // not required
		return nil
	}

	for i := 0; i < len(m.Sysctls); i++ {
		if swag.IsZero(m.Sysctls[i]) { // not required
			continue
		}

		if m.Sysctls[i] != nil {
			if err := m.Sysctls[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sysctls" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sysctls" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this v1 workload instance security context based on the context it is used
func (m *V1WorkloadInstanceSecurityContext) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSysctls(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1WorkloadInstanceSecurityContext) contextValidateSysctls(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Sysctls); i++ {

		if m.Sysctls[i] != nil {
			if err := m.Sysctls[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sysctls" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sysctls" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1WorkloadInstanceSecurityContext) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1WorkloadInstanceSecurityContext) UnmarshalBinary(b []byte) error {
	var res V1WorkloadInstanceSecurityContext
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
